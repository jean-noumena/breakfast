package breakfast

// const ISS = "http://localhost:11000"; // "https://keycloak-public-breakfast.noumena.cloud/realms/breakfast"; // TODO add issuer
const ISS = "https://keycloak-public-breakfast.noumena.cloud/realms/breakfast";

/**
 * Represents a breakfast registration entry
 * @param participant The participant who registered
 * @param registeredAt The timestamp when registration occurred
 */
struct Registration {
    participant: Participant,
    registeredAt: DateTime
};

/**
 * Breakfast event protocol for team breakfast registration
 * @param organizer The party organizing the breakfast event
 * @param eventDate The date of the breakfast event
 * @param maxParticipants The maximum number of participants allowed
 */
@api
protocol[organizer, everyone] BreakfastEvent(
    var name: Text,
    var whatYouBring: Optional<Text>,
    var eventDate: LocalDate,
) {

    initial state open;
    final state completed;
    final state cancelled;

    private var registrations = listOf<Registration>();
    var participantCount: Number = 0;

    /* not used as the everyone party is required for the participant protocol to be able to call the registerAsParticipant permission
    init {
        this.observers = mapOf(
            Pair("everyone", partyOf(
                mapOf(
                    Pair("iss", setOf(ISS))
                )
            ))
        );
        info(this.observers);
    }*/

    @api
    permission[organizer] updateEventDetails(newName: Text, newWhatYouBring: Optional<Text>, newEventDate: LocalDate) | open {
        name = newName;
        whatYouBring = newWhatYouBring;
        eventDate = newEventDate;
    };

    /**
     * Register a participant for the breakfast event
     * @param participant The participant protocol instance to register
     */
    @api
    permission[organizer] register(participant: Participant) | open {
        var registration = Registration(
            participant = participant,
            registeredAt = now()
        );
        registrations = registrations.with(registration);
        participantCount = participantCount + 1;
    };

    permission[*participant] registerAsParticipant(participantProtocol: Participant) | open {
        this.register[organizer](participantProtocol);
    };

    /**
     * Remove a participant registration
     * @param participant The participant protocol instance to remove
     */
    @api
    permission[organizer] unregister(participant: Participant) | open {
        var matchingReg = registrations.filter(function(r: Registration) -> r.participant == participant).firstOrNone();
        require(matchingReg.isPresent(), "No registration found for this participant");
        registrations = registrations.without(matchingReg.getOrFail());
        participantCount = participantCount - 1;
    };

    /**
     * Mark the event as completed
     */
    @api
    obligation[organizer] complete() before eventDate.atStartOfDay("Z").plus(days(1)) | open {
        become completed;
    } otherwise become completed;

    /**
     * Cancel the breakfast event
     */
    @api
    permission[organizer] cancel() | open {
        become cancelled;
    };

    /**
     * Get all registered participants
     * @return List of all registrations
     */
    @api
    permission[organizer] getRegistrations() returns List<Registration> | open, completed, cancelled {
        return registrations;
    };
};
