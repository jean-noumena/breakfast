package breakfast

function participantOf(email: Text) returns Party -> {
    return partyOf(
        mapOf(
            Pair("email", setOf(email)),
            Pair("iss", setOf(ISS))
        )
    );
}


function everyoneOf() returns Party -> {
    return partyOf(
        mapOf(
            Pair("iss", setOf(ISS))
        )
    );
}

/**
 * End-to-end flow test: Complete breakfast registration lifecycle
 */
@test
function test_complete_breakfast_flow(test: Test) -> {
    // Step 1: Create participant protocols for team members
    var aliceParty = participantOf("alice@company.com");
    var bobParty = participantOf("bob@company.com");
    var carolParty = participantOf("carol@company.com");
    var daveParty = participantOf("dave@company.com");
    var organizerParty = participantOf("organizer@company.com");
    var everyone = everyoneOf();

    var alice = Participant[aliceParty, everyone](name = "Alice Smith");
    var bob = Participant[bobParty, everyone](name = "Bob Jones");
    var carol = Participant[carolParty, everyone](name = "Carol White");
    var dave = Participant[daveParty, everyone](name = "Dave Brown");

    // Step 2: Create a breakfast event for 5 people
    var breakfast = BreakfastEvent[organizerParty, everyone]();

    // Verify initial state
    test.assertEquals(BreakfastEvent.States.open, breakfast.activeState().getOrFail(), "Event should start in open state");
    test.assertEquals(0, breakfast.getRegistrationCount[organizerParty](), "Should start with no registrations");

    // Step 3: Register participants
    breakfast.registerAsParticipant[aliceParty](alice);
    test.assertEquals(1, breakfast.getRegistrationCount[organizerParty](), "Should have 1 registration");
    test.assertEquals(BreakfastEvent.States.open, breakfast.activeState().getOrFail(), "Should still be open");

    breakfast.registerAsParticipant[bobParty](bob);
    test.assertEquals(2, breakfast.getRegistrationCount[organizerParty](), "Should have 2 registrations");
    test.assertEquals(BreakfastEvent.States.open, breakfast.activeState().getOrFail(), "Should still be open");
    breakfast.registerAsParticipant[carolParty](carol);
    test.assertEquals(3, breakfast.getRegistrationCount[organizerParty](), "Should have 3 registrations");
    // Step 4: Register additional participants (no limit)
    breakfast.registerAsParticipant[daveParty](dave);

    // Step 5: Get all registrations
    // organizerParty already declared above
    var allRegistrations = breakfast.getRegistrations[organizerParty]();
    test.assertEquals(4, allRegistrations.size(), "Should have 4 registrations");
    test.assertEquals("Alice Smith", allRegistrations.get(0).participant.name, "First participant should be Alice");
    test.assertEquals("Bob Jones", allRegistrations.get(1).participant.name, "Second participant should be Bob");
    test.assertEquals("Carol White", allRegistrations.get(2).participant.name, "Third participant should be Carol");

    // Step 6: Unregister a participant
    breakfast.unregister[organizerParty](bob);
    test.assertEquals(3, breakfast.getRegistrationCount[organizerParty](), "Should have 3 registrations after unregister");
    test.assertEquals(BreakfastEvent.States.open, breakfast.activeState().getOrFail(), "Should transition back to open state");

    // Step 7: Register another participant in the freed spot
    breakfast.register[organizerParty](dave);
    test.assertEquals(4, breakfast.getRegistrationCount[organizerParty](), "Should have 4 registrations again");
    // No full state, event remains open
    // Step 8: Register more participants (no limit)
    breakfast.register[organizerParty](bob);
    test.assertEquals(5, breakfast.getRegistrationCount[organizerParty](), "Should have 5 registrations");

    // Step 10: Complete the event
    breakfast.complete[organizerParty]();
    test.assertEquals(BreakfastEvent.States.completed, breakfast.activeState().getOrFail(), "Event should be completed");

    // Step 11: Verify final registrations are still accessible
    var finalRegistrations = breakfast.getRegistrations[organizerParty]();
    test.assertEquals(5, finalRegistrations.size(), "Should still have 5 registrations after completion");
};

/**
 * Test participant update functionality
 */
@test
function test_participant_updates(test: Test) -> {
    // Create a participant
    var johnParty = participantOf("john@company.com");
    var everyone = everyoneOf();
    var participant = Participant[johnParty, everyone](name = "John Doe");

    test.assertEquals("John Doe", participant.name, "Initial name should be John Doe");

    // Update name
    participant.updateName[johnParty]("John Smith");
    test.assertEquals("John Smith", participant.name, "Name should be updated to John Smith");

    // Try to set empty name (should fail)
    test.assertFails(
        function() -> participant.updateName[johnParty]("") ,
        "Should not allow empty name"
    );
};

/**
 * Test event cancellation flow
 */
@test
function test_event_cancellation(test: Test) -> {
    var aliceParty = participantOf("alice@company.com");
    var bobParty = participantOf("bob@company.com");
    var everyone = everyoneOf();
    var alice = Participant[aliceParty, everyone](name = "Alice");
    var bob = Participant[bobParty, everyone](name = "Bob");

    var organizerParty = participantOf("organizer@company.com");
    var breakfast = BreakfastEvent[organizerParty, everyone]();

    breakfast.register[organizerParty](alice);
    breakfast.register[organizerParty](bob);

    test.assertEquals(2, breakfast.getRegistrationCount[organizerParty](), "Should have 2 registrations");

    // Cancel the event
    breakfast.cancel[organizerParty]();
    test.assertEquals(BreakfastEvent.States.cancelled, breakfast.activeState().getOrFail(), "Event should be cancelled");
};

/**
 * Test capacity management
 */
@test
function test_capacity_management(test: Test) -> {
    var aliceParty = participantOf("alice@company.com");
    var bobParty = participantOf("bob@company.com");
    var carolParty = participantOf("carol@company.com");
    var everyone = everyoneOf();
    var alice = Participant[aliceParty, everyone](name = "Alice");
    var bob = Participant[bobParty, everyone](name = "Bob");
    var carol = Participant[carolParty, everyone](name = "Carol");

    var organizerParty = participantOf("organizer@company.com");
    var breakfast = BreakfastEvent[organizerParty, everyone]();

    breakfast.register[organizerParty](alice);
    breakfast.register[organizerParty](bob);

    // Unlimited attendance: no capacity management needed
    breakfast.register[organizerParty](carol);
    test.assertEquals(3, breakfast.getRegistrationCount[organizerParty](), "Should have 3 registrations after adding carol");
};

/**
 * Test unregistering non-existent participant
 */
@test
function test_unregister_non_existent(test: Test) -> {
    var aliceParty = participantOf("alice@company.com");
    var bobParty = participantOf("bob@company.com");
    var everyone = everyoneOf();
    var alice = Participant[aliceParty, everyone](name = "Alice");
    var bob = Participant[bobParty, everyone](name = "Bob");

    var organizerParty = participantOf("organizer@company.com");
    var breakfast = BreakfastEvent[organizerParty, everyone]();

    breakfast.register[organizerParty](alice);

    // Try to unregister someone who never registered
    test.assertFails(
        function() -> breakfast.unregister[organizerParty](bob),
        "Should fail when trying to unregister non-existent participant"
    );
};
